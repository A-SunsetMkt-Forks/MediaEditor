#include <sstream>
#include <algorithm>
#include <vector>
#include <cstring>
#include "SubtitleTrack_AssImpl.h"
#include "FFUtils.h"
extern "C"
{
    #include "libavutil/avutil.h"
    #include "libswscale/swscale.h"
}

using namespace std;
using namespace DataLayer;
using namespace Logger;
using std::placeholders::_1;

static void PrintAssStyle(ALogger* logger, ASS_Style* s)
{
    logger->Log(DEBUG) << "------------------- ASS Style --------------------" << endl;
    logger->Log(DEBUG) << '\t' << "Name: " << s->Name << endl;
    logger->Log(DEBUG) << '\t' << "FontName: " << s->FontName << endl;
    logger->Log(DEBUG) << '\t' << "FontSize: " << s->FontSize << endl;
    logger->Log(DEBUG) << '\t' << "PrimaryColor: " << s->PrimaryColour << endl;
    logger->Log(DEBUG) << '\t' << "SecondaryColor: " << s->SecondaryColour << endl;
    logger->Log(DEBUG) << '\t' << "OutlineColor:" << s->OutlineColour << endl;
    logger->Log(DEBUG) << '\t' << "BackColor: " << s->BackColour << endl;
    logger->Log(DEBUG) << '\t' << "Bold: " << s->Bold << endl;
    logger->Log(DEBUG) << '\t' << "Italic: " << s->Italic << endl;
    logger->Log(DEBUG) << '\t' << "Underline: " << s->Underline << endl;
    logger->Log(DEBUG) << '\t' << "StrikeOut: " << s->StrikeOut << endl;
    logger->Log(DEBUG) << '\t' << "ScaleX: " << s->ScaleX << endl;
    logger->Log(DEBUG) << '\t' << "ScaleY: " << s->ScaleY << endl;
    logger->Log(DEBUG) << '\t' << "Spacing: " << s->Spacing << endl;
    logger->Log(DEBUG) << '\t' << "Angle: " << s->Angle << endl;
    logger->Log(DEBUG) << '\t' << "BorderStyle: " << s->BorderStyle << endl;
    logger->Log(DEBUG) << '\t' << "Outline: " << s->Outline << endl;
    logger->Log(DEBUG) << '\t' << "Shadow: " << s->Shadow << endl;
    logger->Log(DEBUG) << '\t' << "Alignment: " << s->Alignment << endl;
    logger->Log(DEBUG) << '\t' << "MarginL: " << s->MarginL << endl;
    logger->Log(DEBUG) << '\t' << "MarginR: " << s->MarginR << endl;
    logger->Log(DEBUG) << '\t' << "MarginV: " << s->MarginV << endl;
    logger->Log(DEBUG) << '\t' << "Encoding: " << s->Encoding << endl;
    logger->Log(DEBUG) << '\t' << "treat_fontname_as_pattern: " << s->treat_fontname_as_pattern << endl;
    logger->Log(DEBUG) << '\t' << "Blur: " << s->Blur << endl;
    logger->Log(DEBUG) << '\t' << "Justify: " << s->Justify << endl;
    logger->Log(DEBUG) << "--------------------------------------------------" << endl;
}

static string GenerateAssHeader(const char* provider,
                                int play_res_x, int play_res_y,
                                const char *font, int font_size,
                                int primary_color, int secondary_color,
                                int outline_color, int back_color,
                                int bold, int italic, int underline,
                                int border_style, int alignment)
{
    char ass_header_buf[1024];
    snprintf(ass_header_buf, sizeof(ass_header_buf),
            "[Script Info]\r\n"
            "; Script generated by %s\r\n"
            "ScriptType: v4.00+\r\n"
            "PlayResX: %d\r\n"
            "PlayResY: %d\r\n"
            "ScaledBorderAndShadow: yes\r\n"
            "\r\n"
            "[V4+ Styles]\r\n"

            /* ASSv4 header */
            "Format: Name, "
            "Fontname, Fontsize, "
            "PrimaryColour, SecondaryColour, OutlineColour, BackColour, "
            "Bold, Italic, Underline, StrikeOut, "
            "ScaleX, ScaleY, "
            "Spacing, Angle, "
            "BorderStyle, Outline, Shadow, "
            "Alignment, MarginL, MarginR, MarginV, "
            "Encoding\r\n"

            "Style: "
            "Default,"             /* Name */
            "%s,%d,"               /* Font{name,size} */
            "&H%x,&H%x,&H%x,&H%x," /* {Primary,Secondary,Outline,Back}Colour */
            "%d,%d,%d,0,"          /* Bold, Italic, Underline, StrikeOut */
            "100,100,"             /* Scale{X,Y} */
            "0,0,"                 /* Spacing, Angle */
            "%d,1,0,"              /* BorderStyle, Outline, Shadow */
            "%d,10,10,10,"         /* Alignment, Margin[LRV] */
            "0\r\n"                /* Encoding */

            "\r\n"
            "[Events]\r\n"
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n",
            provider,
            play_res_x, play_res_y, font, font_size,
            primary_color, secondary_color, outline_color, back_color,
            -bold, -italic, -underline, border_style, alignment);

    return string(ass_header_buf);
}

SubtitleTrackStyle_AssImpl::SubtitleTrackStyle_AssImpl(const ASS_Style* style)
{
    BuildFromAssStyle(style);
}

SubtitleTrackStyle_AssImpl::SubtitleTrackStyle_AssImpl(const SubtitleTrackStyle_AssImpl& a)
{
    BuildFromAssStyle(&a.m_style);
    m_scale = a.m_scale;
    m_marginV = a.m_marginV;
}

SubtitleTrackStyle_AssImpl& SubtitleTrackStyle_AssImpl::operator=(const SubtitleTrackStyle_AssImpl& a)
{
    BuildFromAssStyle(&a.m_style);
    m_scale = a.m_scale;
    m_marginV = a.m_marginV;
    return *this;
}

void SubtitleTrackStyle_AssImpl::BuildFromAssStyle(const ASS_Style* assStyle)
{
    memcpy(&m_style, assStyle, sizeof(m_style));
    int l = strlen(assStyle->Name);
    m_name = unique_ptr<char[]>(new char[l+1]);
    snprintf(m_name.get(), l+1, "%s", assStyle->Name);
    m_style.Name = m_name.get();
    l = strlen(assStyle->FontName);
    m_fontName = unique_ptr<char[]>(new char[l+1]);
    snprintf(m_fontName.get(), l+1, "%s", assStyle->FontName);
    m_style.FontName = m_fontName.get();
    uint32_t c = assStyle->PrimaryColour;
    m_primaryColor = SubtitleClip::Color((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    c = assStyle->SecondaryColour;
    m_secondaryColor = SubtitleClip::Color((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
    c = assStyle->OutlineColour;
    m_outlineColor = SubtitleClip::Color((float)(c>>24)/255, (float)((c>>16)&0xff)/255, (float)((c>>8)&0xff)/255, (float)(255-(c&0xff))/255);
}

void SubtitleTrackStyle_AssImpl::SetFont(const string& font)
{
    int l = font.size();
    unique_ptr<char[]> newfont(new char[l+1]);
    snprintf(newfont.get(), l+1, "%s", font.c_str());
    m_fontName = move(newfont);
    m_style.FontName = m_fontName.get();
}

void SubtitleTrackStyle_AssImpl::SetPrimaryColor(const SubtitleClip::Color& color)
{
    m_primaryColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_style.PrimaryColour = c;
}

void SubtitleTrackStyle_AssImpl::SetSecondaryColor(const SubtitleClip::Color& color)
{
    m_secondaryColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_style.SecondaryColour = c;
}

void SubtitleTrackStyle_AssImpl::SetOutlineColor(const SubtitleClip::Color& color)
{
    m_outlineColor = color;
    uint32_t c = ((uint32_t)(color.r*255)<<24) | ((uint32_t)(color.g*255)<<16) | ((uint32_t)(color.b*255)<<8) | (uint32_t)((1-color.a)*255);
    m_style.OutlineColour = c;
}

static bool SubClipSortCmp(const SubtitleClipHolder& a, const SubtitleClipHolder& b)
{
    return a->StartTime() < b->StartTime();
}

SubtitleTrack_AssImpl::SubtitleTrack_AssImpl(int64_t id)
    : m_id(id)
{
    m_logger = GetSubtitleTrackLogger();
    m_currIter = m_clips.begin();
}

SubtitleTrack_AssImpl::~SubtitleTrack_AssImpl()
{
    if (m_assrnd)
    {
        ass_renderer_done(m_assrnd);
        m_assrnd = nullptr;
    }
    if (m_asstrk)
    {
        ass_free_track(m_asstrk);
        m_asstrk = nullptr;
    }
    ReleaseFFContext();
}

bool SubtitleTrack_AssImpl::InitAss()
{
    if (!s_asslib)
    {
        m_errMsg = "ASS library has NOT been INITIALIZED!";
        return false;
    }
    m_assrnd = ass_renderer_init(s_asslib);
    if (!m_assrnd)
    {
        m_errMsg = "FAILED to initialize ASS renderer!";
        return false;
    }
    ass_set_fonts(m_assrnd, NULL, NULL, ASS_FONTPROVIDER_AUTODETECT, NULL, 1);
    m_asstrk = ass_new_track(s_asslib);
    if (!m_asstrk)
    {
        m_errMsg = "FAILED to create a new ASS track!";
        return false;
    }
    return true;
}

bool SubtitleTrack_AssImpl::SetFrameSize(uint32_t width, uint32_t height)
{
    ass_set_frame_size(m_assrnd, width, height);
    m_frmW = width;
    m_frmH = height;
    return true;
}

bool SubtitleTrack_AssImpl::EnableFullSizeOutput(bool enable)
{
    if (m_outputFullSize == enable)
        return true;
    m_outputFullSize = enable;
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBackgroundColor(const SubtitleClip::Color& color)
{
    m_bgColor = color;
    for (SubtitleClipHolder clip : m_clips)
        clip->SetBackgroundColor(color);
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetFont(const std::string& font)
{
    m_logger->Log(DEBUG) << "Set font '" << font << "'" << endl;
    m_overrideStyle.SetFont(font);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetScale(double scale)
{
    m_logger->Log(DEBUG) << "Set font scale " << scale << endl;
    m_overrideStyle.SetScale(scale);
    ass_set_font_scale(m_assrnd, scale);
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetScaleX(double value)
{
    m_logger->Log(DEBUG) << "Set scaleX '" << value << "'" << endl;
    m_overrideStyle.SetScaleX(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetScaleY(double value)
{
    m_logger->Log(DEBUG) << "Set scaleY '" << value << "'" << endl;
    m_overrideStyle.SetScaleX(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetSpacing(double value)
{
    m_logger->Log(DEBUG) << "Set spacing '" << value << "'" << endl;
    m_overrideStyle.SetSpacing(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetAngle(double value)
{
    m_logger->Log(DEBUG) << "Set angle '" << value << "'" << endl;
    m_overrideStyle.SetAngle(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetOutlineWidth(double value)
{
    m_logger->Log(DEBUG) << "Set outline '" << value << "'" << endl;
    m_overrideStyle.SetOutlineWidth(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetAlignment(int value)
{
    m_logger->Log(DEBUG) << "Set alignment '" << value << "'" << endl;
    m_overrideStyle.SetAlignment(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetMarginH(int value)
{
    m_logger->Log(DEBUG) << "Set marginH '" << value << "'" << endl;
    m_overrideStyle.SetMarginH(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetMarginV(int value)
{
    m_logger->Log(DEBUG) << "Set marginV '" << value << "'" << endl;
    m_overrideStyle.SetMarginV(value);
    // ass_set_use_margins(m_assrnd, 1);
    // ass_set_margins(m_assrnd, value, 0, 0, 0);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetItalic(int value)
{
    m_logger->Log(DEBUG) << "Set italic '" << value << "'" << endl;
    m_overrideStyle.SetItalic(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetBold(int value)
{
    m_logger->Log(DEBUG) << "Set bold '" << value << "'" << endl;
    m_overrideStyle.SetBold(value);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetUnderLine(bool enable)
{
    m_logger->Log(DEBUG) << "Set underline '" << enable << "'" << endl;
    m_overrideStyle.SetUnderLine(enable);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetStrikeOut(bool enable)
{
    m_logger->Log(DEBUG) << "Set strikeout '" << enable << "'" << endl;
    m_overrideStyle.SetStrikeOut(enable);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetPrimaryColor(const SubtitleClip::Color& color)
{
    m_logger->Log(DEBUG) << "Set primary color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetPrimaryColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetSecondaryColor(const SubtitleClip::Color& color)
{
    m_logger->Log(DEBUG) << "Set secondary color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetSecondaryColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::SetOutlineColor(const SubtitleClip::Color& color)
{
    m_logger->Log(DEBUG) << "Set outline color as { r(" << color.r << "), g(" << color.g << "), b(" << color.b << "), a(" << color.a << ") }" << endl;
    m_overrideStyle.SetOutlineColor(color);
    ass_set_selective_style_override(m_assrnd, m_overrideStyle.GetAssStylePtr());
    if (!m_useOverrideStyle)
        ToggleOverrideStyle();
    ClearRenderCache();
    return true;
}

bool SubtitleTrack_AssImpl::ChangeClipTime(SubtitleClipHolder clip, int64_t startTime, int64_t duration)
{
    if (!clip)
    {
        m_errMsg = "Argument 'clip' CANNOT be NULL!";
        return false;
    }
    int32_t idx = 0;
    auto iter = m_clips.begin();
    while (iter != m_clips.end())
    {
        if (*iter == clip)
            break;
        idx++;
        iter++;
    }
    if (iter == m_clips.end())
    {
        m_errMsg = "Can NOT FIND the target clip in the clip list!";
        return false;
    }
    if (clip->StartTime() == startTime && clip->Duration() == duration)
    {
        // does not change anything
        return true;
    }

    // Invalidate the clips which affected by the target clip
    auto iter2 = iter;
    while (iter2 != m_clips.end())
    {
        iter2++;
        if (iter2 != m_clips.end() && clip->EndTime() > (*iter2)->StartTime())
            (*iter2)->InvalidateImage();
        else
            break;
    }

    // calculate the variation of the index after the clip time changed
    iter2 = iter;
    int indexVariation = 0;
    if (startTime > clip->StartTime())
    {
        iter2++;
        while (iter2 != m_clips.end() && startTime > (*iter2)->StartTime())
        {
            (*iter2)->InvalidateImage();
            indexVariation++;
            iter2++;
        }
    }
    else if (startTime < clip->StartTime())
    {
        while (iter2 != m_clips.begin())
        {
            iter2--;
            if (startTime < (*iter2)->StartTime())
            {
                (*iter2)->InvalidateImage();
                indexVariation--;
            }
            else
            {
                iter2++;
                break;
            }
        }
    }

    // if no index variation is needed, then just update the time attributes is enough
    if (indexVariation == 0)
    {
        clip->SetStartTime(startTime);
        clip->SetDuration(duration);
        clip->InvalidateImage();
        ASS_Event* e = m_asstrk->events+idx;
        e->Start = startTime;
        e->Duration = duration;
        return true;
    }

    // else, move the target clip to the new position
    m_clips.erase(iter);
    m_clips.insert(iter2, clip);
    while (iter2 != m_clips.end())
    {
        if (clip->EndTime() > (*iter2)->StartTime())
        {
            (*iter2)->InvalidateImage();
            iter2++;
        }
        else
            break;
    }
    clip->SetStartTime(startTime);
    clip->SetDuration(duration);
    ASS_Event tmp{m_asstrk->events[idx]};
    tmp.Start = startTime;
    tmp.Duration = duration;
    if (indexVariation > 0)
    {
        memmove(m_asstrk->events+idx, m_asstrk->events+idx+1, sizeof(ASS_Event)*indexVariation);
        m_asstrk->events[idx+indexVariation] = tmp;
    }
    else
    {
        memmove(m_asstrk->events+idx+indexVariation+1, m_asstrk->events+idx+indexVariation, sizeof(ASS_Event)*(-indexVariation));
        m_asstrk->events[idx+indexVariation] = tmp;
    }

    // update duration
    if (!m_clips.empty())
    {
        m_duration = m_clips.back()->EndTime();
    }
    return true;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetClipByTime(int64_t ms)
{
    if (m_clips.size() <= 0)
        return nullptr;
    if (m_currIter != m_clips.end() && (*m_currIter)->StartTime() <= ms && (*m_currIter)->EndTime() > ms)
        return *m_currIter;

    if (m_currIter == m_clips.end() || (*m_currIter)->StartTime() > ms)
    {
        auto iter = m_currIter;
        while (iter != m_clips.begin())
        {
            iter--;
            if ((*iter)->EndTime() <= ms)
            {
                iter++;
                break;
            }
            else if ((*iter)->StartTime() <= ms)
            {
                break;
            }
        }
        m_currIter = iter;
    }
    else
    {
        auto iter = m_currIter;
        iter++;
        while (iter != m_clips.end())
        {
            if ((*iter)->EndTime() > ms)
                break;
            iter++;
        }
        m_currIter = iter;
    }

    if (m_currIter == m_clips.end())
        return nullptr;
    if ((*m_currIter)->StartTime() <= ms && (*m_currIter)->EndTime() > ms)
        return *m_currIter;
    return nullptr;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetCurrClip()
{
    if (m_currIter == m_clips.end())
        return nullptr;
    return *m_currIter;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetPrevClip()
{
    if (m_currIter == m_clips.begin())
        return nullptr;
    m_currIter--;
    return *m_currIter;
}

SubtitleClipHolder SubtitleTrack_AssImpl::GetNextClip()
{
    if (m_currIter == m_clips.end())
        return nullptr;
    m_currIter++;
    if (m_currIter == m_clips.end())
        return nullptr;
    return *m_currIter;
}

int32_t SubtitleTrack_AssImpl::GetClipIndex(SubtitleClipHolder clip) const
{
    if (!clip)
        return -1;
    int32_t idx = 0;
    auto iter = m_clips.begin();
    while (iter != m_clips.end())
    {
        if (*iter == clip)
            break;
        idx++;
        iter++;
    }
    if (iter == m_clips.end())
        return -1;
    return idx;
}

bool SubtitleTrack_AssImpl::SeekToTime(int64_t ms)
{
    m_readPos = ms;
    auto iter = find_if(m_clips.begin(), m_clips.end(), [ms] (SubtitleClipHolder clip) {
        return clip->StartTime() > ms;
    });
    m_currIter = iter;
    if (iter != m_clips.begin())
    {
        iter--;
        if ((*iter)->EndTime() > ms)
            m_currIter = iter;
    }

    return true;
}

bool SubtitleTrack_AssImpl::SeekToIndex(uint32_t index)
{
    if (index >= m_clips.size())
    {
        ostringstream oss;
        oss << "Index (" << index << ") exceeds the number of subtitle clips (" << m_clips.size() << ")!";
        m_errMsg = oss.str();
        return false;
    }
    uint32_t loopCnt = index;
    auto iter = m_clips.begin();
    while (loopCnt > 0 && iter != m_clips.end())
    {
        iter++;
        loopCnt--;
    }
    m_currIter = iter;
    m_readPos = (*iter)->StartTime();
    return true;
}

SubtitleClipHolder SubtitleTrack_AssImpl::NewClip(int64_t startTime, int64_t duration)
{
    auto iter = m_clips.begin();
    int readOrder = 0;
    while (iter != m_clips.end() && (*iter)->StartTime() <= startTime)
    {
        iter++;
        readOrder++;
    }

    const string text = "";
    SubtitleClipHolder hNewClip(new SubtitleClip(DataLayer::ASS, readOrder, startTime, duration, text));
    hNewClip->SetRenderCallback(bind(&SubtitleTrack_AssImpl::RenderSubtitleClip, this, _1));
    hNewClip->SetBackgroundColor(m_bgColor);
    m_clips.insert(iter, hNewClip);

    const int fakeReadOrder = m_asstrk->n_events;
    const int layer = 0;
    const string style = "Default";
    const string speaker = "";
    ostringstream oss;
    oss << fakeReadOrder << "," << layer << "," << style << "," << speaker << ",0,0,0,," << text;
    string assline = oss.str();
    ass_process_chunk(m_asstrk, (char*)assline.c_str(), assline.size(), startTime, duration);
    // adjust events order in ASS_Track
    ASS_Event newEvent{m_asstrk->events[fakeReadOrder]};
    newEvent.ReadOrder = readOrder;
    if (fakeReadOrder > readOrder)
    {
        memmove(m_asstrk->events+readOrder+1, m_asstrk->events+readOrder, sizeof(ASS_Event)*(fakeReadOrder-readOrder));
        m_asstrk->events[readOrder] = newEvent;
    }

    ASS_Event* eventPtr = m_asstrk->events+readOrder;
    while (iter != m_clips.end())
    {
        readOrder++;  eventPtr++;
        (*iter++)->SetReadOrder(readOrder);
        eventPtr->ReadOrder = readOrder;
    }

    // update duration
    if (!m_clips.empty())
    {
        m_duration = m_clips.back()->EndTime();
    }

    m_logger->Log(DEBUG) << "New added clip readOrder=" << hNewClip->ReadOrder() << "." << endl;
    return hNewClip;
}

bool SubtitleTrack_AssImpl::ChangeText(uint32_t clipIndex, const string& text)
{
    if (clipIndex >= m_clips.size())
        return false;

    auto iter = m_clips.begin();
    uint32_t i = clipIndex;
    while (iter != m_clips.end() && i > 0)
    {
        iter++;
        i--;
    }
    if (iter == m_clips.end())
        return false;

    return ChangeText(*iter, text);
}

bool SubtitleTrack_AssImpl::ChangeText(SubtitleClipHolder clip, const string& text)
{
    ASS_Event* target = nullptr;
    for (int i = 0; i < m_asstrk->n_events; i++)
    {
        ASS_Event* e = m_asstrk->events+i;
        if (e->ReadOrder == clip->ReadOrder())
        {
            target = e;
            break;
        }
    }
    if (!target)
        return false;

    if (target->Text)
        free(target->Text);
    int len = text.size();
    target->Text = (char*)malloc(len+1);
    memcpy(target->Text, text.c_str(), len);
    target->Text[len] = 0;
    clip->SetText(text);
    clip->InvalidateImage();

    return true;
}

ASS_Library* SubtitleTrack_AssImpl::s_asslib = nullptr;

static void ass_log(int ass_level, const char *fmt, va_list args, void *ctx)
{
    Logger::Level level = VERBOSE;
    if (ass_level < 2)
        level = Error;
    else if (ass_level < 4)
        level = WARN;
    else if (ass_level < 5)
        level = INFO;
    else if (ass_level < 6)
        level = DEBUG;
    char buf[2048]={0};
    va_list vl;
    va_copy(vl, args);
    vsnprintf(buf, sizeof(buf)-1, fmt, vl);
    va_end(vl);
    GetSubtitleTrackLogger()->Log(level) << "[ASSLOG] " << buf << endl;
}

bool SubtitleTrack_AssImpl::Initialize()
{
    if (s_asslib)
    {
        // already initialized
        return true;
    }
    s_asslib = ass_library_init();
    if (!s_asslib)
        return false;
    ass_set_message_cb(s_asslib, ass_log, NULL);
    return true;
}

void SubtitleTrack_AssImpl::Release()
{
    if (s_asslib)
    {
        ass_library_done(s_asslib);
        s_asslib = nullptr;
    }
}

bool SubtitleTrack_AssImpl::SetFontDir(const string& path)
{
    if (!s_asslib)
        return false;
    ass_set_fonts_dir(s_asslib, path.c_str());
    return true;
}

bool SubtitleTrack_AssImpl::ReadFile(const string& path)
{
    ReleaseFFContext();

    int fferr;
    fferr = avformat_open_input(&m_pAvfmtCtx, path.c_str(), nullptr, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avformat_open_input() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    fferr = avformat_find_stream_info(m_pAvfmtCtx, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avformat_find_stream_info() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    int subStmIdx = -1;
    for (int i = 0; i < m_pAvfmtCtx->nb_streams; i++)
    {
        if (m_pAvfmtCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE)
        {
            subStmIdx = i;
            break;
        }
    }
    if (subStmIdx < 0)
    {
        ostringstream oss;
        oss << "CANNOT find any subtitle track in the file '" << path << "'!";
        m_errMsg = oss.str();
        return false;
    }

    AVStream* pAvStream = m_pAvfmtCtx->streams[subStmIdx];
    AVCodecPtr pAvCdc = avcodec_find_decoder(pAvStream->codecpar->codec_id);
    AVCodecContext* pAvCdcCtx = avcodec_alloc_context3(pAvCdc);
    fferr = avcodec_parameters_to_context(pAvCdcCtx, pAvStream->codecpar);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avcodec_parameters_to_context() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }
    pAvCdcCtx->pkt_timebase = pAvStream->time_base;
    fferr = avcodec_open2(pAvCdcCtx, pAvCdc, nullptr);
    if (fferr < 0)
    {
        ostringstream oss;
        oss << "avcodec_open2() FAILED! fferr=" << fferr << ".";
        m_errMsg = oss.str();
        return false;
    }

    if (pAvCdcCtx->subtitle_header && pAvCdcCtx->subtitle_header_size > 0)
    {
        ass_process_codec_private(m_asstrk, (char*)pAvCdcCtx->subtitle_header, pAvCdcCtx->subtitle_header_size);
        if (m_asstrk->styles && m_asstrk->n_styles > 0)
        {
            m_logger->Log(DEBUG) << m_asstrk->n_styles << " style(s) are found:" << endl;
            for (int i = 0; i < m_asstrk->n_styles; i++)
                PrintAssStyle(m_logger, m_asstrk->styles+i);
        }
    }

    m_errMsg.clear();
    bool demuxEof = false;
    bool decodeEof = false;
    while (!decodeEof)
    {
        AVPacket avpkt{0};
        if (!demuxEof)
        {
            fferr = av_read_frame(m_pAvfmtCtx, &avpkt);
            if (fferr == AVERROR_EOF)
            {
                demuxEof = true;
            }
            else if (fferr < 0)
            {
                ostringstream oss;
                oss << "av_read_frame() FAILED! fferr=" << fferr << ".";
                m_errMsg = oss.str();
                break;
            }
        }
        else
        {
            // send NULL packet to decoder to push out all subtitles if any is buffered inside
            avpkt.stream_index = subStmIdx;
        }

        AVSubtitle avsub{0};
        int gotSubPtr = 0;
        if (avpkt.stream_index == subStmIdx)
        {
            fferr = avcodec_decode_subtitle2(pAvCdcCtx, &avsub, &gotSubPtr, &avpkt);
            av_packet_unref(&avpkt);
            if (fferr == AVERROR_EOF)
            {
                decodeEof = true;
            }
            else if (fferr < 0)
            {
                ostringstream oss;
                oss << "avcodec_decode_subtitle2() FAILED! fferr=" << fferr << ".";
                m_errMsg = oss.str();
                break;
            }
        }
        else
        {
            av_packet_unref(&avpkt);
            continue;
        }

        if (gotSubPtr)
        {
            const int64_t start_time = av_rescale_q(avsub.pts, AV_TIME_BASE_Q, av_make_q(1, 1000));
            const int64_t duration   = avsub.end_display_time;
            m_logger->Log(VERBOSE) << "[" << MillisecToString(start_time) << "(+" << duration << ")] ";
            bool isAss = true;
            for (auto i = 0; i < avsub.num_rects; i++)
            {
                if (avsub.rects[i]->type != SUBTITLE_ASS)
                {
                    isAss = false;
                    break;
                }
                char *ass_line = avsub.rects[i]->ass;
                if (!ass_line)
                    continue;
                m_logger->Log(VERBOSE) << "<" << i << ">: '" << avsub.rects[i]->ass << "'; ";
            }
            m_logger->Log(VERBOSE) << endl;
            if (!isAss)
            {
                m_logger->Log(Error) << "Only support ASS subtitle (or convertable to ASS) for now!" << endl;
                m_errMsg = "The subtitle file/stream is NOT ASS! Not supported!";
                break;
            }
            for (auto i = 0; i < avsub.num_rects; i++)
            {
                char *ass_line = avsub.rects[i]->ass;
                if (!ass_line)
                    break;
#if LIBAVCODEC_VERSION_MAJOR >= 59
                ass_process_chunk(m_asstrk, ass_line, strlen(ass_line), start_time, duration);
#else
                ass_process_data(m_asstrk, ass_line, strlen(ass_line));
#endif
            }
            avsubtitle_free(&avsub);
        }
        else if (demuxEof)
        {
            decodeEof = true;
        }
    }

    bool success = m_errMsg.empty();
    if (success)
    {
        if (m_asstrk->n_styles > 0)
        {
            m_overrideStyle = SubtitleTrackStyle_AssImpl(m_asstrk->styles+m_asstrk->n_styles-1);
        }

        for (int i = 0; i < m_asstrk->n_events; i++)
        {
            ASS_Event* e = m_asstrk->events+i;
            SubtitleClipHolder hSubClip(new SubtitleClip(DataLayer::ASS, e->ReadOrder, e->Start, e->Duration, e->Text));
            hSubClip->SetRenderCallback(bind(&SubtitleTrack_AssImpl::RenderSubtitleClip, this, _1));
            hSubClip->SetBackgroundColor(m_bgColor);
            m_clips.push_back(hSubClip);
            m_currIter = m_clips.begin();
        }
        if (!m_clips.empty())
        {
            m_duration = m_clips.back()->EndTime();
        }
    }
    return success;
}

void SubtitleTrack_AssImpl::ReleaseFFContext()
{
    if (m_pAvCdcCtx)
    {
        avcodec_free_context(&m_pAvCdcCtx);
        m_pAvCdcCtx = nullptr;
    }
    if (m_pAvfmtCtx)
    {
        avformat_close_input(&m_pAvfmtCtx);
        m_pAvfmtCtx = nullptr;
    }
}

template <typename T>
class WrapperAlloc: public allocator<T>
{
public:
    WrapperAlloc(void* buf=0) throw(): allocator<T>(), m_buf(buf) {}
    WrapperAlloc(const WrapperAlloc& a) throw(): allocator<T>(a) { m_buf = a.m_buf; }
    ~WrapperAlloc() {}

    typedef size_t size_type;
    typedef T* pointer;
    typedef const T* const_pointer;

    template<typename _Tp1>
    struct rebind
    {
        typedef WrapperAlloc<_Tp1> other;
    };

    pointer allocate(size_type n, const void* hint=0)
    {
        char* p = new (m_buf) char[n*sizeof(T)];
        return (T*)p;
    }

    void deallocate(pointer p, size_type n) {}

private:
    void* m_buf;
};

SubtitleImage SubtitleTrack_AssImpl::RenderSubtitleClip(SubtitleClip* clip)
{
    int detectChange = 0;
    ASS_Image* renderRes = ass_render_frame(m_assrnd, m_asstrk, clip->StartTime(), &detectChange);
    m_logger->Log(DEBUG) << "Render subtitle '" << clip->Text() << "', ASS_Image ptr=" << renderRes << ", detectChanged=" << detectChange << "." << endl;
    ImGui::ImMat vmat;
    if (!renderRes)
        return SubtitleImage(vmat, {0});

    // calculate the containing box
    ASS_Image* assImage = renderRes;
    SubtitleImage::Rect containBox{assImage->dst_x, assImage->dst_y, assImage->w, assImage->h};
    assImage = assImage->next;
    while (assImage)
    {
        if (assImage->dst_x < containBox.x)
        {
            containBox.w += containBox.x-assImage->dst_x;
            containBox.x = assImage->dst_x;
        }
        if (assImage->dst_x+assImage->w > containBox.x+containBox.w)
        {
            containBox.w = assImage->dst_x+assImage->w-containBox.x;
        }
        if (assImage->dst_y < containBox.y)
        {
            containBox.h += containBox.y-assImage->dst_y;
            containBox.y = assImage->dst_y;
        }
        if (assImage->dst_y+assImage->h > containBox.y+containBox.h)
        {
            containBox.h = assImage->dst_y+assImage->h-containBox.y;
        }
        assImage = assImage->next;
    }

    int frmW = (int)m_frmW;
    int frmH = (int)m_frmH;
    if (!m_outputFullSize)
    {
        frmW = containBox.w;
        frmH = containBox.h;
    }
    vmat.create_type((int)frmW, (int)frmH, 4, IM_DT_INT8);
    vmat.color_format = IM_CF_RGBA;

    uint32_t color;
    // fill the image with background color
    const SubtitleClip::Color bgColor = clip->BackgroundColor();
    color = ((uint32_t)(bgColor.a*255)<<24) | ((uint32_t)(bgColor.b*255)<<16) | ((uint32_t)(bgColor.g*255)<<8) | (uint32_t)(bgColor.r*255);
    WrapperAlloc<uint32_t> wrapperAlloc((uint32_t*)vmat.data);
    vector<uint32_t, WrapperAlloc<uint32_t>> mapary(wrapperAlloc);
    mapary.resize(vmat.total()/4);
    fill(mapary.begin(), mapary.end(), color);

    // draw ASS_Image list
    assImage = renderRes;
    while (assImage)
    {
        color = assImage->color;
        float baseAlpha = (float)(255-(color&0xff))/255;
        color = ((color&0xff00)<<8) | ((color>>8)&0xff00) | ((color>>24)&0xff);
        uint32_t* linePtr;
        if (m_outputFullSize)
            linePtr = (uint32_t*)(vmat.data)+assImage->dst_y*frmW+assImage->dst_x;
        else
            linePtr = (uint32_t*)(vmat.data)+(assImage->dst_y-containBox.y)*frmW+(assImage->dst_x-containBox.x);
        unsigned char* assPtr = assImage->bitmap;
        for (int i = 0; i < assImage->h; i++)
        {
            for (int j = 0; j < assImage->w; j++)
            {
                const unsigned char b = assPtr[j];
                if (b > 0)
                {
                    uint32_t alpha = (uint32_t)(baseAlpha*b);
                    linePtr[j] = color | (alpha<<24);
                }
            }
            linePtr += frmW;
            assPtr += assImage->stride;
        }
        assImage = assImage->next;
    }

    return SubtitleImage(vmat, containBox);
}

void SubtitleTrack_AssImpl::ClearRenderCache()
{
    for (auto clip : m_clips)
        clip->InvalidateImage();
}

void SubtitleTrack_AssImpl::ToggleOverrideStyle()
{
    int bit = ASS_OVERRIDE_DEFAULT;
    m_useOverrideStyle = !m_useOverrideStyle;
    if (m_useOverrideStyle)
        bit = ASS_OVERRIDE_FULL_STYLE;
    ass_set_selective_style_override_enabled(m_assrnd, bit);
}

void SubtitleTrack_AssImpl::ResetClipListReadOrder()
{
    int readOrder = 0;
    auto iter = m_clips.begin();
    while (iter != m_clips.end())
    {
        (*iter++)->SetReadOrder(readOrder++);
    }
}

SubtitleTrackHolder SubtitleTrack_AssImpl::BuildFromFile(int64_t id, const string& url)
{
    ALogger* logger = GetSubtitleTrackLogger();
    SubtitleTrack_AssImpl* asssubtrk = new SubtitleTrack_AssImpl(id);
    SubtitleTrackHolder hSubTrk = SubtitleTrackHolder(asssubtrk);
    if (!asssubtrk->InitAss())
    {
        logger->Log(Error) << hSubTrk->GetError() << endl;
        return nullptr;
    }

    bool success = asssubtrk->ReadFile(url);
    asssubtrk->ReleaseFFContext();

    if (!success)
    {
        logger->Log(Error) << asssubtrk->GetError() << endl;
        return nullptr;
    }
    return hSubTrk;
}

SubtitleTrackHolder SubtitleTrack_AssImpl::NewEmptyTrack(int64_t id)
{
    ALogger* logger = GetSubtitleTrackLogger();
    SubtitleTrack_AssImpl* asssubtrk = new SubtitleTrack_AssImpl(id);
    SubtitleTrackHolder hSubTrk = SubtitleTrackHolder(asssubtrk);
    if (!asssubtrk->InitAss())
    {
        logger->Log(Error) << hSubTrk->GetError() << endl;
        return nullptr;
    }

    string assHeader = GenerateAssHeader("MediaEditor", 384, 288, "Arial", 16, 0xffffff, 0xffffff, 0, 0, 0, 0, 0, 1, 2);
    ass_process_codec_private(asssubtrk->m_asstrk, (char*)assHeader.c_str(), assHeader.size());
    return hSubTrk;
}

